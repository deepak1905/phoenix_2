-- VHDL Entity r2bfly_lib.cmult1_v2_3.symbol
--
-- Created:
--          by - konsta.UNKNOWN (GOSK)
--          at - 13:24:26 22.04.2005
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2004.1 (Build 41)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY cmult1_v2_3 IS
   PORT( 
      A       : IN     std_logic_vector (15 DOWNTO 0);
      B       : IN     std_logic_vector (15 DOWNTO 0);
      CD      : IN     std_logic_vector (15 DOWNTO 0);
      clk     : IN     std_logic;
      load    : IN     std_logic;
      rst     : IN     std_logic;
      imagout : OUT    std_logic_vector (15 DOWNTO 0);
      realout : OUT    std_logic_vector (15 DOWNTO 0)
   );

-- Declarations

END cmult1_v2_3 ;

--
-- VHDL Architecture r2bfly_lib.cmult1_v2_3.struct
--
-- Created:
--          by - konsta.UNKNOWN (GOSK)
--          at - 13:24:26 22.04.2005
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2004.1 (Build 41)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;


ARCHITECTURE struct OF cmult1_v2_3 IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL CA     : std_logic_vector(15 DOWNTO 0);
   SIGNAL CB     : std_logic_vector(15 DOWNTO 0);
   SIGNAL DA     : std_logic_vector(15 DOWNTO 0);
   SIGNAL DB     : std_logic_vector(15 DOWNTO 0);
   SIGNAL dout0  : std_logic_vector(15 DOWNTO 0);
   SIGNAL dout1  : std_logic_vector(15 DOWNTO 0);
   SIGNAL mult_1 : std_logic_vector(31 DOWNTO 0);
   SIGNAL mult_2 : std_logic_vector(31 DOWNTO 0);


   -- ModuleWare signal declarations(v1.4) for instance 'I4' of 'adff'
   SIGNAL mw_I4reg_cval : std_logic_vector(15 DOWNTO 0);

   -- ModuleWare signal declarations(v1.4) for instance 'I5' of 'adff'
   SIGNAL mw_I5reg_cval : std_logic_vector(15 DOWNTO 0);

   -- ModuleWare signal declarations(v1.4) for instance 'I6' of 'split'
   SIGNAL mw_I6temp_din : std_logic_vector(31 DOWNTO 0);

   -- ModuleWare signal declarations(v1.4) for instance 'I7' of 'split'
   SIGNAL mw_I7temp_din : std_logic_vector(31 DOWNTO 0);


BEGIN

   -- ModuleWare code(v1.4) for instance 'I0' of 'add'
   I0combo_proc: PROCESS (CB, DA)
   VARIABLE temp_din0 : std_logic_vector(16 DOWNTO 0);
   VARIABLE temp_din1 : std_logic_vector(16 DOWNTO 0);
   VARIABLE sum : signed(16 DOWNTO 0);
   VARIABLE carry : std_logic;
   BEGIN
      temp_din0 := CB(15) & CB;
      temp_din1 := DA(15) & DA;
      carry := '0';
      sum := signed(temp_din0) + signed(temp_din1) + carry;
      imagout <= conv_std_logic_vector(sum(15 DOWNTO 0),16);
   END PROCESS I0combo_proc;

   -- ModuleWare code(v1.4) for instance 'I4' of 'adff'
   CA <= mw_I4reg_cval;
   -- synopsys async_set_reset_local of I4seq_proc "rst"
   I4seq_proc: PROCESS (clk, rst)
   BEGIN
      IF (rst = '0' OR rst = 'L') THEN
         mw_I4reg_cval <= "0000000000000000";
      ELSIF (clk'EVENT AND clk='1') THEN
         IF (load = '1' OR load = 'H') THEN
            mw_I4reg_cval <= DA;
         END IF;
      END IF;
   END PROCESS I4seq_proc;

   -- ModuleWare code(v1.4) for instance 'I5' of 'adff'
   CB <= mw_I5reg_cval;
   -- synopsys async_set_reset_local of I5seq_proc "rst"
   I5seq_proc: PROCESS (clk, rst)
   BEGIN
      IF (rst = '0' OR rst = 'L') THEN
         mw_I5reg_cval <= "0000000000000000";
      ELSIF (clk'EVENT AND clk='1') THEN
         IF (load = '1' OR load = 'H') THEN
            mw_I5reg_cval <= DB;
         END IF;
      END IF;
   END PROCESS I5seq_proc;

   -- ModuleWare code(v1.4) for instance 'I1' of 'mult'
   I1combo_proc : PROCESS (B, CD)
   VARIABLE temp_in_prod : signed(31 DOWNTO 0);
   BEGIN
      temp_in_prod := (signed(B) * signed(CD));
      mult_2 <= std_logic_vector(temp_in_prod);
   END PROCESS I1combo_proc;

   -- ModuleWare code(v1.4) for instance 'I3' of 'mult'
   I3combo_proc : PROCESS (A, CD)
   VARIABLE temp_in_prod : signed(31 DOWNTO 0);
   BEGIN
      temp_in_prod := (signed(A) * signed(CD));
      mult_1 <= std_logic_vector(temp_in_prod);
   END PROCESS I3combo_proc;

   -- ModuleWare code(v1.4) for instance 'I6' of 'split'
   mw_I6temp_din <= mult_1;
   I6combo_proc: PROCESS (mw_I6temp_din)
   VARIABLE itemp: std_logic_vector(31 DOWNTO 0);
   BEGIN
      itemp := mw_I6temp_din(31 DOWNTO 0);
      dout0 <= itemp(15 DOWNTO 0);
      DA <= itemp(31 DOWNTO 16);
   END PROCESS I6combo_proc;

   -- ModuleWare code(v1.4) for instance 'I7' of 'split'
   mw_I7temp_din <= mult_2;
   I7combo_proc: PROCESS (mw_I7temp_din)
   VARIABLE itemp: std_logic_vector(31 DOWNTO 0);
   BEGIN
      itemp := mw_I7temp_din(31 DOWNTO 0);
      dout1 <= itemp(15 DOWNTO 0);
      DB <= itemp(31 DOWNTO 16);
   END PROCESS I7combo_proc;

   -- ModuleWare code(v1.4) for instance 'I2' of 'sub'
   I2combo_proc: PROCESS (CA, DB)
   VARIABLE temp_din0 : std_logic_vector(16 DOWNTO 0);
   VARIABLE temp_din1 : std_logic_vector(16 DOWNTO 0);
   VARIABLE diff : signed(16 DOWNTO 0);
   VARIABLE borrow : std_logic;
   BEGIN
      temp_din0 := CA(15) & CA;
      temp_din1 := DB(15) & DB;
      borrow := '0';
      diff := signed(temp_din0) - signed(temp_din1) - borrow;
      realout <= conv_std_logic_vector(diff(15 DOWNTO 0),16);
   END PROCESS I2combo_proc;

   -- Instance port mappings.

END struct;
